@page "/upload"
@using System.IO
@using System.Text
@using System.Net.Http.Headers
@using System.Text.Json
@using System.Numerics
@using Microsoft.Extensions.Configuration
@using Models

@inject HttpClient httpClient
@inject NavigationManager NavigationManager
@inject IJSRuntime JsRuntime
@inject IConfiguration Configuration

@* https://docs.microsoft.com/en-us/aspnet/core/blazor/advanced-scenarios?view=aspnetcore-3.1#perform-large-data-transfers-in-blazor-server-apps *@


<h1>Upload</h1>

<div class="mb-5">
    <input @bind="additionalText" type="text" class="form-control mb-1" name="addition_text" style="height:50px" placeholder="Please type in ..." autofocus/>
    <InputFile OnChange=OnFileInputChanged class="btn-lg form-control btn btn-outline-primary mb-1" style="height:80px" name="input_file" multiple/>
    @if (this.isLoading)
    {
        <button disabled type="submit" class="btn-lg form-control btn btn-outline-secondary" style="height:50px" @onclick=OnButtonSubmit_Click>Submitting...</button>
    }
    else
    {
        <button type="submit" class="btn-lg form-control btn btn-outline-secondary" style="height:50px" @onclick=OnButtonSubmit_Click>Submit</button>
    }
</div>

<ul style="word-wrap: break-word">
    @foreach (var item in listItems.AsEnumerable().Reverse())
    {
        <li @key=item.Filename>
            <div class="card m-2">
                @(item.Filename)
                <br/>
                @item.FileSizeHumanReadable
                <br/>
                @($"{item.Process * 100:0} %")
            </div>
        </li>
    }
</ul>

@code {
    private string additionalText;
    private List<FileSliceInfoModel> listItems = new();
    private static int bufferSize = 1024 * 1024 * 4;
    private byte[] buffer = new byte[bufferSize];
    private bool isLoading = false;
    private IReadOnlyList<IBrowserFile> selectedFiles;

    protected override async Task OnInitializedAsync()
    {
        @* this.httpClient.BaseAddress = new Uri(this.NavigationManager.BaseUri); *@
        this.httpClient.BaseAddress = new Uri(this.Configuration["BackendBaseUrl"]);
    }

    public async Task OnButtonSubmit_Click()
    {
        UploadTextAsync();
        UploadFilesAsync();
    }

    private async Task UploadTextAsync()
    {
        HttpRequestMessage request = new(HttpMethod.Post, "api/fileupload/text")
        {
            Content = new StringContent(JsonSerializer.Serialize(new TextModel { Text = additionalText }), Encoding.UTF8, "application/json")
        };
        var httpResponse = await this.httpClient.SendAsync(request);
    }

    private async Task UploadFilesAsync()
    {
        this.isLoading = true;
        StateHasChanged();

        try
        {
            foreach (var file in this.selectedFiles)
            {
                UploadSingleFileByChunkAsync(file);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[Error] {ex.Message}");
        }

        this.isLoading = false;
        StateHasChanged();
    }

    private async Task UploadSingleFileByChunkAsync(IBrowserFile file)
    {
        if (file != null)
        {
            // Phone might share the same stream with all the files.
            // this shall not be executes in parallel.
            using (var stream = file.OpenReadStream(long.MaxValue)) {
                int fileSize = (int)file.Size;
                int start = 0;
                int end = 0;
                do
                {
                    end = start + bufferSize;
                    if (end > fileSize)
                    {
                        end = fileSize;
                    }

                    byte[] buffer = await SliceFileAsync(stream, start, end, this.buffer);
                    bool isSendGood = await TrySendFileAsync(buffer, start, end, file.Name, fileSize);
                    if (!isSendGood)
                    {
                        fileSize = (int)file.Size;
                        start = 0;
                        end = 0;
                        continue;
                    }
                    start += bufferSize;

                } while (end < fileSize);
            }
        }
    }

    private async Task<byte[]> SliceFileAsync(Stream stream, int start, int end, byte[] buffer)
    {
        if (stream.Position != start)
        {
            // this is not supported.
            // it will throw an error.
            stream.Position = start;
        }
        // Do (async) stuff with stream...
        await stream.ReadAsync(buffer, 0, end - start);

        // return newBuffer;
        return buffer;
    }

    private async Task<bool> TrySendFileAsync(byte[] piece, int start, int end, string filename, int fileSize)
    {
        FileSliceModel fileSlice = new()
        {
            Piece = piece,
            Start = start,
            End = end,
            Filename = filename,
            FileSize = fileSize,
            FilePieceHashCode = new BigInteger(piece).GetHashCode(),
        };
        HttpRequestMessage request = new(HttpMethod.Post, "api/fileupload/filepiece")
        {
            Content = new StringContent(JsonSerializer.Serialize(fileSlice), Encoding.UTF8, "application/json")
        };

        var httpResponse = await this.httpClient.SendAsync(request);
        int tryCount = 0;
        while (!httpResponse.IsSuccessStatusCode)
        {
            if (tryCount > 3)
            {
                return false;
            }
            httpResponse = await this.httpClient.SendAsync(request);
            tryCount++;
        }
        string response = await httpResponse.Content.ReadAsStringAsync();
        
        FileSliceInfoModel fileSliceInfo = new()
        {
            End = fileSlice.End,
            FilePieceHashCode = fileSlice.FilePieceHashCode,
            Filename = fileSlice.Filename,
            FileSize = fileSlice.FileSize,
            Start = fileSlice.Start
        };
        int listItemIndex = this.listItems.FindIndex(xxxx => xxxx.Filename == fileSlice.Filename);
        if (listItemIndex == -1)
        {
            this.listItems.Add(fileSliceInfo);
        }
        else
        {
            this.listItems.RemoveAt(listItemIndex);
            this.listItems.Insert(listItemIndex, fileSliceInfo);
        }

        this.StateHasChanged();
        return true;
    }

    private void OnFileInputChanged(InputFileChangeEventArgs e)
    {
        this.selectedFiles = e.GetMultipleFiles(int.MaxValue);
    }
}
